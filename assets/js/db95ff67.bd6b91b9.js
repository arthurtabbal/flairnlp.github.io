"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6989],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),g=r,d=c["".concat(o,".").concat(g)]||c[g]||m[g]||i;return n?a.createElement(d,l(l({ref:t},u),{},{components:n})):a.createElement(d,l({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=g;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[c]="string"==typeof e?e:r,l[1]=s;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},7520:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={slug:"flair-0.12",title:"Announcing Flair 0.12",authors:"alan",tags:["release","flair"]},l=void 0,s={permalink:"/blog/flair-0.12",editUrl:"https://github.com/flairNLP/flairnlp.github.io/edit/main/blog/2023-04-03-first-post.md",source:"@site/blog/2023-04-03-first-post.md",title:"Announcing Flair 0.12",description:"Flair version 0.12 is finally released, with tons of new features, enhancements and bug fixes. With this post, we give an overview of some cool new features.",date:"2023-04-03T00:00:00.000Z",formattedDate:"April 3, 2023",tags:[{label:"release",permalink:"/blog/tags/release"},{label:"flair",permalink:"/blog/tags/flair"}],readingTime:4.24,hasTruncateMarker:!0,authors:[{name:"Alan Akbik",title:"Creator of Flair",url:"https://github.com/alanakbik",imageURL:"https://github.com/alanakbik.png",key:"alan"}],frontMatter:{slug:"flair-0.12",title:"Announcing Flair 0.12",authors:"alan",tags:["release","flair"]}},o={authorsImageUrls:[void 0]},p=[{value:"New Feature: Simplified Tagging",id:"new-feature-simplified-tagging",level:2},{value:"New Tagger: Entity Linking",id:"new-tagger-entity-linking",level:2},{value:"New Tagger: Multilingual Frames",id:"new-tagger-multilingual-frames",level:2},{value:"New Language: Support for Ukrainian",id:"new-language-support-for-ukrainian",level:2},{value:"Other New Features",id:"other-new-features",level:2}],u={toc:p},c="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Flair version 0.12 is finally released, with tons of new features, enhancements and bug fixes. With this post, we give an overview of some cool new features."),(0,r.kt)("h2",{id:"new-feature-simplified-tagging"},"New Feature: Simplified Tagging"),(0,r.kt)("p",null,"We now offer a unified way of loading all Flair models and accessing all Flair predictions. That means that users no longer need to know the underlying model class to get Flair predictions."),(0,r.kt)("p",null,"We illustrate the new simplicity with two examples: one for predicting named entities, and one for predicting sentiment. You'll see the code is now ",(0,r.kt)("strong",{parentName:"p"},"basically identical")," for both:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1: Tagging Named Entities")),(0,r.kt)("p",null,"Let's run ",(0,r.kt)("strong",{parentName:"p"},"named entity recognition")," (NER) over an example sentence. All you need to do is make a ",(0,r.kt)("inlineCode",{parentName:"p"},"Sentence"),", load a pre-trained model and use it to predict tags for the sentence:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"from flair.data import Sentence\nfrom flair.nn import Classifier\n\n# make a sentence\nsentence = Sentence('I love Berlin .')\n\n# load the NER tagger\ntagger = Classifier.load('ner')\n\n# run NER over sentence\ntagger.predict(sentence)\n\n# print the sentence with all annotations\nprint(sentence)\n")),(0,r.kt)("p",null,"This should print:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coffeescript"},'Sentence: "I love Berlin ." \u2192 ["Berlin"/LOC]\n')),(0,r.kt)("p",null,'This means that "Berlin" was tagged as a ',(0,r.kt)("strong",{parentName:"p"},"location entity")," in this sentence."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2: Tagging Sentiment")),(0,r.kt)("p",null,"Let's run ",(0,r.kt)("strong",{parentName:"p"},"sentiment analysis")," over the same example sentence to determine whether it is POSITIVE or NEGATIVE. Same code as above, just a different model:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"from flair.data import Sentence\nfrom flair.nn import Classifier\n\n# make a sentence\nsentence = Sentence('I love Berlin .')\n\n# load the sentiment tagger\ntagger = Classifier.load('sentiment')\n\n# run sentiment analysis over sentence\ntagger.predict(sentence)\n\n# print the sentence with all annotations\nprint(sentence)\n")),(0,r.kt)("p",null,"This should print:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},'Sentence[4]: "I love Berlin ." \u2192 POSITIVE (0.9983)\n')),(0,r.kt)("p",null,'This means that the sentence "I love Berlin" was tagged as having ',(0,r.kt)("strong",{parentName:"p"},"POSITIVE")," sentiment."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"As you can see, the two examples are basically the same code."),' The only difference is the model you loaded ("ner" vs "sentiment")!'),(0,r.kt)("h2",{id:"new-tagger-entity-linking"},"New Tagger: Entity Linking"),(0,r.kt)("p",null,"As of Flair 0.12 we ship an ",(0,r.kt)("strong",{parentName:"p"},"experimental entity linker")," trained on the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/flairNLP/zelda"},"Zelda dataset"),". The linker not only tags entities, but also attempts to link each entity to the corresponding Wikipedia URL if one exists."),(0,r.kt)("p",null,'To illustrate, let\'s use the example sentence "Kirk and Spock met on the Enterprise." The code is the same as above, just load the ',(0,r.kt)("strong",{parentName:"p"},"linker")," model:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"from flair.nn import Classifier\nfrom flair.data import Sentence\n\n# load the model\ntagger = Classifier.load('linker')\n\n# make a sentence\nsentence = Sentence('Kirk and Spock met on the Enterprise.')\n\n# predict entity links\ntagger.predict(sentence)\n\n# iterate over predicted entities and print\nfor label in sentence.get_labels():\n    print(label)\n")),(0,r.kt)("p",null,"This should print:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coffeescript"},'Span[0:1]: "Kirk" \u2192 James_T._Kirk (0.9969)\nSpan[2:3]: "Spock" \u2192 Spock (0.9971)\nSpan[6:7]: "Enterprise" \u2192 USS_Enterprise_(NCC-1701-D) (0.975)\n')),(0,r.kt)("p",null,"As we can see, the linker can resolve that:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'"Kirk" refers to the entity "',(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/James_T._Kirk"},"James","_","T.","_","Kirk"),'"\n'),(0,r.kt)("li",{parentName:"ul"},'"Spock" refers to "',(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Spock"},"Spock"),'" ',(0,r.kt)("em",{parentName:"li"},"(ok, that one was easy)")),(0,r.kt)("li",{parentName:"ul"},'"Enterprise" refers to the "',(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/USS_Enterprise_(NCC-1701-D)"},"USS","_","Enterprise","_","(NCC-1701-D)"),'"\n')),(0,r.kt)("p",null,"Not bad, eh? However, that last prediction is not quite correct as fans of Star Trek will know. Entity linking is a hard task and we are working to improve the accuracy of our model."),(0,r.kt)("h2",{id:"new-tagger-multilingual-frames"},"New Tagger: Multilingual Frames"),(0,r.kt)("p",null,"As of Flair 0.12.2 we als include a first ",(0,r.kt)("strong",{parentName:"p"},"multilingual frame tagger")," trained on a mix of data including three languages from the ",(0,r.kt)("a",{parentName:"p",href:"https://universalpropositions.github.io/"},"Universal Proposition Banks"),". This makes our frame detection more robust to other languages. "),(0,r.kt)("p",null,"To illustrate, let's use a German example sentence \"",(0,r.kt)("em",{parentName:"p"},"Dirk trug einen Koffer und trug einen Hut."),'" with the ',(0,r.kt)("strong",{parentName:"p"},"frame-large")," model:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# load the large frame model\nmodel = Classifier.load(\'frame-large\')\n\n# German sentence with the verb "trug" in two different senses\nsentence_de = Sentence("Dirk trug einen Koffer und trug einen Hut.")\n\n# predict frames\nmodel.predict(sentence_de)\n\n# print predictions\nprint(sentence_de) \n')),(0,r.kt)("p",null,"This should print:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Sentence[9]: "Dirk trug einen Koffer und trug einen Hut." \u2192 ["trug"/carry.01, "trug"/wear.01]\n')),(0,r.kt)("p",null,'This output tells us that the first instance of the verb "',(0,r.kt)("em",{parentName:"p"},"trug"),'" is meant in the sense of ',(0,r.kt)("em",{parentName:"p"},"carrying something"),' (in this case, a suitcase). The second instance of the verb "',(0,r.kt)("em",{parentName:"p"},"trug"),'" is meant in the sense of ',(0,r.kt)("em",{parentName:"p"},"wearing something")," (in this case, a suitcase)."),(0,r.kt)("h2",{id:"new-language-support-for-ukrainian"},"New Language: Support for Ukrainian"),(0,r.kt)("p",null,"This version adds support for Ukrainian taggers, embeddings and datasets. For instance, to do named entity tagging of a Ukrainian sentence, do:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"from flair.nn import Classifier\nfrom flair.data import Sentence\n\n# load the Ukrainian NER model\ntagger = Classifier.load('ner-ukrainian')\n\n# make a sentence\nsentence = Sentence('\u042f \u043b\u044e\u0431\u043b\u044e \u0411\u0435\u0440\u043b\u0456\u043d.')\n\n# predict entity links\ntagger.predict(sentence)\n\n# print sentence with predictions\nprint(sentence)\n")),(0,r.kt)("p",null,"This should print:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-coffeescript"},'Sentence[4]: "\u042f \u043b\u044e\u0431\u043b\u044e \u0411\u0435\u0440\u043b\u0456\u043d." \u2192 ["\u0411\u0435\u0440\u043b\u0456\u043d"/LOC]\n')),(0,r.kt)("p",null,'This means that "\u0411\u0435\u0440\u043b\u0456\u043d" was tagged as a ',(0,r.kt)("strong",{parentName:"p"},"location entity")," in this sentence."),(0,r.kt)("h2",{id:"other-new-features"},"Other New Features"),(0,r.kt)("p",null,"There are a host of new features in this release, but discussing them all would be too much for this post. Important new features include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Support for multitask learning in Flair\n"),(0,r.kt)("li",{parentName:"ul"},"Major internal refactorings for easier code maintenance\n"),(0,r.kt)("li",{parentName:"ul"},"Updated tutorials and better documentation\n"),(0,r.kt)("li",{parentName:"ul"},"Improved accuracy in our FLERT models\n")),(0,r.kt)("p",null,"We will look at these and other features in separate posts in more detail! ",(0,r.kt)("strong",{parentName:"p"},"Stay tuned!")))}m.isMDXComponent=!0}}]);